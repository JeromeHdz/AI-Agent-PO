// Mock fs.promises module
const mockWriteFile = jest.fn().mockResolvedValue();
jest.mock("fs", () => ({
  promises: {
    writeFile: mockWriteFile,
  },
}));

const {
  writeThemesToMarkdown,
  writeFeaturesToMarkdown,
  writeMarkdown,
} = require("../../../src/utils/markdownWriter");

describe("writeThemesToMarkdown", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockWriteFile.mockResolvedValue();
  });

  it("should write themes to markdown file", async () => {
    const themes = [
      "Users want dark mode for better visibility",
      "Mobile app performance needs improvement",
      "Interface should be more intuitive",
    ];

    await writeThemesToMarkdown(themes, "test-themes.md");

    expect(mockWriteFile).toHaveBeenCalledWith(
      "test-themes.md",
      expect.stringContaining("# User Feedback Themes"),
      "utf8"
    );

    const callArgs = mockWriteFile.mock.calls[0];
    const content = callArgs[1];

    expect(content).toContain("Generated from 3 thematic feedback groups");
    expect(content).toContain("- Users want dark mode for better visibility");
    expect(content).toContain("- Mobile app performance needs improvement");
    expect(content).toContain("- Interface should be more intuitive");
    expect(content).toContain("*Generated by AI Agent Builder - Phase 1*");
  });

  it("should throw error for non-array input", async () => {
    await expect(
      writeThemesToMarkdown("not an array", "test.md")
    ).rejects.toThrow("Themes must be an array");
  });

  it("should handle empty themes array", async () => {
    await writeThemesToMarkdown([], "empty-themes.md");

    expect(mockWriteFile).toHaveBeenCalledWith(
      "empty-themes.md",
      expect.stringContaining("Generated from 0 thematic feedback groups"),
      "utf8"
    );
  });
});

describe("writeFeaturesToMarkdown", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockWriteFile.mockResolvedValue();
  });

  it("should write features with prioritization to markdown", async () => {
    const results = {
      features: [
        {
          name: "Dark Mode",
          description: "Users want dark theme",
          objective: "Improve user experience",
          examples: "Toggle switch, auto-detect",
          impact: "high",
        },
        {
          name: "Mobile Performance",
          description: "App is slow on mobile",
          objective: "Improve mobile experience",
          examples: "Faster loading, smoother animations",
          impact: "high",
        },
      ],
      moscow: {
        must: ["Dark Mode"],
        should: ["Mobile Performance"],
        could: [],
        wont: [],
        justification: "Dark mode is essential for user experience",
      },
      rice: [
        {
          name: "Dark Mode",
          rice: {
            reach: 8,
            impact: 9,
            confidence: 8,
            effort: 3,
            score: 192,
            justification: "High user demand",
          },
        },
        {
          name: "Mobile Performance",
          rice: {
            reach: 9,
            impact: 8,
            confidence: 7,
            effort: 4,
            score: 126,
            justification: "Critical for mobile users",
          },
        },
      ],
      kano: [
        {
          name: "Dark Mode",
          kano: {
            type: "must-have",
            justification: "Users expect dark theme",
          },
        },
        {
          name: "Mobile Performance",
          kano: {
            type: "performance",
            justification: "Better performance improves satisfaction",
          },
        },
      ],
      summary: {
        totalFeatures: 2,
        moscowMust: 1,
        moscowShould: 1,
        topRiceScore: 192,
        kanoMustHave: 1,
        kanoPerformance: 1,
        kanoExcitement: 0,
      },
    };

    await writeFeaturesToMarkdown(results, "test-features.md");

    expect(mockWriteFile).toHaveBeenCalledWith(
      "test-features.md",
      expect.stringContaining("# Extracted Features & Prioritization"),
      "utf8"
    );

    const callArgs = mockWriteFile.mock.calls[0];
    const content = callArgs[1];

    expect(content).toContain(
      "Generated from 2 features extracted from user feedback themes"
    );
    expect(content).toContain("### 1. Dark Mode");
    expect(content).toContain("### 2. Mobile Performance");
    expect(content).toContain("## âš–ï¸ MoSCoW Prioritization");
    expect(content).toContain("## ðŸ“Š RICE Prioritization");
    expect(content).toContain("## ðŸŽ¯ Kano Model Classification");
    expect(content).toContain("*Generated by AI Agent Builder - Phase 2*");
  });

  it("should throw error for invalid results", async () => {
    await expect(writeFeaturesToMarkdown({}, "test.md")).rejects.toThrow(
      "Results must contain features array"
    );

    await expect(
      writeFeaturesToMarkdown({ features: null }, "test.md")
    ).rejects.toThrow("Results must contain features array");
  });
});

describe("writeMarkdown", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockWriteFile.mockResolvedValue();
  });

  it("should write generic data to markdown", async () => {
    const data = [
      { name: "John", age: 30, city: "New York" },
      { name: "Jane", age: 25, city: "Los Angeles" },
    ];

    await writeMarkdown(data, "test-generic.md", "Test Data");

    expect(mockWriteFile).toHaveBeenCalledWith(
      "test-generic.md",
      expect.stringContaining("# Test Data"),
      "utf8"
    );

    const callArgs = mockWriteFile.mock.calls[0];
    const content = callArgs[1];

    expect(content).toContain("Generated from 2 items");
    expect(content).toContain("## 1. John");
    expect(content).toContain("## 2. Jane");
    expect(content).toContain("- **age**: 30");
    expect(content).toContain("- **city**: New York");
    expect(content).toContain("- **age**: 25");
    expect(content).toContain("- **city**: Los Angeles");
    expect(content).toContain("*Generated by AI Agent Builder*");
  });

  it("should throw error for non-array input", async () => {
    await expect(
      writeMarkdown("not an array", "test.md", "Test")
    ).rejects.toThrow("Data must be an array");
  });

  it("should handle empty data array", async () => {
    await writeMarkdown([], "empty-data.md", "Empty Data");

    expect(mockWriteFile).toHaveBeenCalledWith(
      "empty-data.md",
      expect.stringContaining("Generated from 0 items"),
      "utf8"
    );
  });
});
