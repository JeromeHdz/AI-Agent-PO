const {
  writeThemesToMarkdown,
  writeFeaturesToMarkdown,
} = require("../../../src/utils/markdownWriter");
const fs = require("fs");

// Mock fs module
jest.mock("fs");

describe("writeThemesToMarkdown", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    fs.writeFile.mockImplementation((path, content, encoding, callback) => {
      callback(null);
    });
  });

  it("should write themes to markdown file", async () => {
    const themes = [
      "Users want dark mode for better visibility",
      "Mobile app performance needs improvement",
      "Interface should be more intuitive",
    ];

    await writeThemesToMarkdown(themes, "test-themes.md");

    expect(fs.writeFile).toHaveBeenCalledWith(
      "test-themes.md",
      expect.stringContaining("# User Feedback Themes"),
      "utf8",
      expect.any(Function)
    );

    const callArgs = fs.writeFile.mock.calls[0];
    const content = callArgs[1];

    expect(content).toContain("Generated from 3 thematic feedback groups");
    expect(content).toContain("- Users want dark mode for better visibility");
    expect(content).toContain("- Mobile app performance needs improvement");
    expect(content).toContain("- Interface should be more intuitive");
    expect(content).toContain("*Generated by AI Agent Builder - Phase 1*");
  });

  it("should throw error for non-array input", async () => {
    await expect(
      writeThemesToMarkdown("not an array", "test.md")
    ).rejects.toThrow("Themes must be an array");
  });

  it("should handle empty themes array", async () => {
    await writeThemesToMarkdown([], "empty-themes.md");

    expect(fs.writeFile).toHaveBeenCalledWith(
      "empty-themes.md",
      expect.stringContaining("Generated from 0 thematic feedback groups"),
      "utf8",
      expect.any(Function)
    );
  });

  it("should handle file write error", async () => {
    const error = new Error("Permission denied");
    fs.writeFile.mockImplementation((path, content, encoding, callback) => {
      callback(error);
    });

    await expect(writeThemesToMarkdown(["theme"], "test.md")).rejects.toThrow(
      "Permission denied"
    );
  });
});

describe("writeFeaturesToMarkdown", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    fs.writeFile.mockImplementation((path, content, encoding, callback) => {
      callback(null);
    });
  });

  it("should write features with prioritization to markdown", async () => {
    const results = {
      features: [
        {
          name: "Dark Mode",
          description: "Users want dark theme",
          objective: "Improve user experience",
          examples: "Toggle switch, auto-detect",
          impact: "high",
        },
        {
          name: "Mobile Performance",
          description: "App is slow on mobile",
          objective: "Improve mobile experience",
          examples: "Faster loading, smoother animations",
          impact: "high",
        },
      ],
      moscow: {
        must: ["Dark Mode"],
        should: ["Mobile Performance"],
        could: [],
        wont: [],
        justification: "Dark mode is essential for user experience",
      },
      rice: [
        {
          name: "Dark Mode",
          rice: {
            reach: 8,
            impact: 9,
            confidence: 8,
            effort: 3,
            score: 192,
            justification: "High user demand",
          },
        },
        {
          name: "Mobile Performance",
          rice: {
            reach: 9,
            impact: 8,
            confidence: 7,
            effort: 4,
            score: 126,
            justification: "Critical for mobile users",
          },
        },
      ],
      kano: [
        {
          name: "Dark Mode",
          kano: {
            type: "must-have",
            justification: "Users expect dark theme",
          },
        },
        {
          name: "Mobile Performance",
          kano: {
            type: "performance",
            justification: "Better performance improves satisfaction",
          },
        },
      ],
      summary: {
        totalFeatures: 2,
        moscowMust: 1,
        moscowShould: 1,
        topRiceScore: 192,
        kanoMustHave: 1,
        kanoPerformance: 1,
        kanoExcitement: 0,
      },
    };

    await writeFeaturesToMarkdown(results, "test-features.md");

    expect(fs.writeFile).toHaveBeenCalledWith(
      "test-features.md",
      expect.stringContaining("# Extracted Features & Prioritization"),
      "utf8",
      expect.any(Function)
    );

    const callArgs = fs.writeFile.mock.calls[0];
    const content = callArgs[1];

    expect(content).toContain("Generated from 2 features");
    expect(content).toContain("### 1. Dark Mode");
    expect(content).toContain("### 2. Mobile Performance");
    expect(content).toContain("## âš–ï¸ MoSCoW Prioritization");
    expect(content).toContain("## ðŸ“Š RICE Prioritization");
    expect(content).toContain("## ðŸŽ¯ Kano Model Classification");
    expect(content).toContain("*Generated by AI Agent Builder - Phase 2*");
  });

  it("should throw error for invalid results", async () => {
    await expect(writeFeaturesToMarkdown(null, "test.md")).rejects.toThrow(
      "Results must contain features array"
    );
  });

  it("should throw error for results without features", async () => {
    const invalidResults = { moscow: {}, rice: [], kano: [] };
    await expect(
      writeFeaturesToMarkdown(invalidResults, "test.md")
    ).rejects.toThrow("Results must contain features array");
  });

  it("should handle empty features array", async () => {
    const results = {
      features: [],
      moscow: { must: [], should: [], could: [], wont: [], justification: "" },
      rice: [],
      kano: [],
      summary: {
        totalFeatures: 0,
        moscowMust: 0,
        moscowShould: 0,
        topRiceScore: 0,
        kanoMustHave: 0,
        kanoPerformance: 0,
        kanoExcitement: 0,
      },
    };

    await writeFeaturesToMarkdown(results, "empty-features.md");

    expect(fs.writeFile).toHaveBeenCalledWith(
      "empty-features.md",
      expect.stringContaining("Generated from 0 features"),
      "utf8",
      expect.any(Function)
    );
  });
});
