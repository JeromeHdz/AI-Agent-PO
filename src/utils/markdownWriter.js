const fs = require("fs").promises;

/**
 * Writes themes to a markdown file.
 * @param {string[]} themes - Array of theme strings
 * @param {string} filePath - Path to the markdown file
 * @returns {Promise<void>}
 */
async function writeThemesToMarkdown(themes, filePath) {
  if (!Array.isArray(themes)) {
    throw new TypeError("Themes must be an array");
  }

  const content = `# User Feedback Themes

Generated from ${themes.length} thematic feedback groups.

${themes.map((theme) => `- ${theme}`).join("\n")}

---
*Generated by AI Agent Builder - Phase 1*`;

  await fs.writeFile(filePath, content, "utf8");
}

/**
 * Writes features with prioritization results to a markdown file.
 * @param {Object} results - Object containing features and prioritization results
 * @param {string} filePath - Path to the markdown file
 * @returns {Promise<void>}
 */
async function writeFeaturesToMarkdown(results, filePath) {
  if (!results || !results.features) {
    throw new TypeError("Results must contain features array");
  }

  const { features, moscow, rice, kano, summary } = results;

  let content = `# Extracted Features & Prioritization

Generated from ${summary.totalFeatures} features extracted from user feedback themes.

## 📋 Extracted Features

`;

  // Add features
  features.forEach((feature, index) => {
    content += `### ${index + 1}. ${feature.name}
- **Description**: ${feature.description}
- **Objective**: ${feature.objective}
- **Examples**: ${feature.examples || "N/A"}
- **Impact**: ${feature.impact}

`;
  });

  // Add MoSCoW prioritization
  content += `## ⚖️ MoSCoW Prioritization

### Must Have
${moscow.must?.map((feature) => `- ${feature}`).join("\n") || "- None"}

### Should Have
${moscow.should?.map((feature) => `- ${feature}`).join("\n") || "- None"}

### Could Have
${moscow.could?.map((feature) => `- ${feature}`).join("\n") || "- None"}

### Won't Have
${moscow.wont?.map((feature) => `- ${feature}`).join("\n") || "- None"}

**Justification**: ${moscow.justification}

`;

  // Add RICE prioritization
  content += `## 📊 RICE Prioritization

| Feature | Reach | Impact | Confidence | Effort | Score | Justification |
|---------|-------|--------|------------|--------|-------|---------------|
`;

  rice.forEach((feature) => {
    const rice = feature.rice;
    content += `| ${feature.name} | ${rice.reach} | ${rice.impact} | ${rice.confidence} | ${rice.effort} | ${rice.score} | ${rice.justification} |\n`;
  });

  content += "\n";

  // Add Kano classification
  content += `## 🎯 Kano Model Classification

| Feature | Type | Justification |
|---------|------|---------------|
`;

  kano.forEach((feature) => {
    const kano = feature.kano;
    content += `| ${feature.name} | ${kano.type} | ${kano.justification} |\n`;
  });

  content += `

## 📈 Summary

- **Total Features**: ${summary.totalFeatures}
- **MoSCoW Must**: ${summary.moscowMust}
- **MoSCoW Should**: ${summary.moscowShould}
- **Top RICE Score**: ${summary.topRiceScore}
- **Kano Must-have**: ${summary.kanoMustHave}
- **Kano Performance**: ${summary.kanoPerformance}
- **Kano Excitement**: ${summary.kanoExcitement}

---
*Generated by AI Agent Builder - Phase 2*`;

  await fs.writeFile(filePath, content, "utf8");
}

/**
 * Generic markdown writer function for any data structure.
 * @param {Array} data - Array of objects to write
 * @param {string} filePath - Path to the markdown file
 * @param {string} title - Title for the markdown file
 * @returns {Promise<void>}
 */
async function writeMarkdown(data, filePath, title) {
  if (!Array.isArray(data)) {
    throw new TypeError("Data must be an array");
  }

  let content = `# ${title}

Generated from ${data.length} items.

`;

  data.forEach((item, index) => {
    content += `## ${index + 1}. ${item.title || item.name || `Item ${index + 1}`}
`;

    Object.entries(item).forEach(([key, value]) => {
      if (key !== "title" && key !== "name") {
        content += `- **${key}**: ${value}
`;
      }
    });

    content += "\n";
  });

  content += `---
*Generated by AI Agent Builder*`;

  await fs.writeFile(filePath, content, "utf8");
}

module.exports = {
  writeThemesToMarkdown,
  writeFeaturesToMarkdown,
  writeMarkdown,
};
